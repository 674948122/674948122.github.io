const e=JSON.parse('{"key":"v-574fee92","path":"/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/monorepo.html","title":"monorepo","lang":"zh-CN","frontmatter":{"title":"monorepo","tag":["monorepo"],"description":"介绍 monorepo是管理多个包的项目，可以理解为一个项目管理多个项目，这些项目可以是相互独立的，也可以是相互依赖的。 优点 代码复用非常简单 在 Monorepo 中，由于我们所有的代码都在同一个项目下，如果我们需要引用其他一些已经定义过的功能模块，会非常方便。 我们只需要将复用频率高的代码，单独抽离出来成为一个 shared 之类的项目，那么其他所有的项目都只需要直接引用这个项目下的代码就可以了。而不用将这个项目重新打包，再在其他项目中使用。 简化依赖管理 由于我们是在同一个项目下，因此对于第三方依赖的管理也会简化很多，像是之前多个项目可能有一些相同的第三方依赖包，每个项目都需要下载一遍，而我们使用 Monorepo 的框架重构项目之后，这些依赖包就可以避免重复下载，同时也能通过配置在不同的项目之间复用。 原子提交能让重构全局特性更容易 当我们的一个库会影响到很多个项目时，修改了这个库之后，以往我们需要一个一个去更新对应受到影响的项目，进行相应的兼容适配工作，而修改一个问题又可能导致另外一个兼容问题。","head":[["meta",{"property":"og:url","content":"https://674948122.github.io/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/monorepo.html"}],["meta",{"property":"og:title","content":"monorepo"}],["meta",{"property":"og:description","content":"介绍 monorepo是管理多个包的项目，可以理解为一个项目管理多个项目，这些项目可以是相互独立的，也可以是相互依赖的。 优点 代码复用非常简单 在 Monorepo 中，由于我们所有的代码都在同一个项目下，如果我们需要引用其他一些已经定义过的功能模块，会非常方便。 我们只需要将复用频率高的代码，单独抽离出来成为一个 shared 之类的项目，那么其他所有的项目都只需要直接引用这个项目下的代码就可以了。而不用将这个项目重新打包，再在其他项目中使用。 简化依赖管理 由于我们是在同一个项目下，因此对于第三方依赖的管理也会简化很多，像是之前多个项目可能有一些相同的第三方依赖包，每个项目都需要下载一遍，而我们使用 Monorepo 的框架重构项目之后，这些依赖包就可以避免重复下载，同时也能通过配置在不同的项目之间复用。 原子提交能让重构全局特性更容易 当我们的一个库会影响到很多个项目时，修改了这个库之后，以往我们需要一个一个去更新对应受到影响的项目，进行相应的兼容适配工作，而修改一个问题又可能导致另外一个兼容问题。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-12T07:49:40.000Z"}],["meta",{"property":"article:author","content":"Mr.PDG"}],["meta",{"property":"article:tag","content":"monorepo"}],["meta",{"property":"article:modified_time","content":"2023-05-12T07:49:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"monorepo\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-05-12T07:49:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.PDG\\",\\"url\\":\\"https://674948122.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":2,"title":"缺点","slug":"缺点","link":"#缺点","children":[]},{"level":2,"title":"项目结构","slug":"项目结构","link":"#项目结构","children":[]},{"level":2,"title":"实施过程","slug":"实施过程","link":"#实施过程","children":[{"level":3,"title":"创建项目","slug":"创建项目","link":"#创建项目","children":[]},{"level":3,"title":"lerna","slug":"lerna","link":"#lerna","children":[]},{"level":3,"title":"初始化项目","slug":"初始化项目","link":"#初始化项目","children":[]},{"level":3,"title":"创建配置文件","slug":"创建配置文件","link":"#创建配置文件","children":[]},{"level":3,"title":"创建子项目","slug":"创建子项目","link":"#创建子项目","children":[]},{"level":3,"title":"创建utils分包","slug":"创建utils分包","link":"#创建utils分包","children":[]},{"level":3,"title":"子项目引入utils分包","slug":"子项目引入utils分包","link":"#子项目引入utils分包","children":[]},{"level":3,"title":"创建components分包","slug":"创建components分包","link":"#创建components分包","children":[]},{"level":3,"title":"子项目引入components分包","slug":"子项目引入components分包","link":"#子项目引入components分包","children":[]}]},{"level":2,"title":"结语","slug":"结语","link":"#结语","children":[]},{"level":2,"title":"常用命令","slug":"常用命令","link":"#常用命令","children":[{"level":3,"title":"pnpm","slug":"pnpm","link":"#pnpm","children":[]},{"level":3,"title":"lerna","slug":"lerna-1","link":"#lerna-1","children":[]}]}],"git":{"createdTime":1683874824000,"updatedTime":1683877780000,"contributors":[{"name":"pandegong","email":"674948122@qq.com","commits":2}]},"readingTime":{"minutes":5.53,"words":1660},"filePathRelative":"前端工程化/monorepo.md","localizedDate":"2023年5月12日","excerpt":"<h2> 介绍</h2>\\n<p><code>monorepo</code>是管理多个包的项目，可以理解为一个项目管理多个项目，这些项目可以是相互独立的，也可以是相互依赖的。</p>\\n<h2> 优点</h2>\\n<ol>\\n<li>代码复用非常简单\\n在 Monorepo 中，由于我们所有的代码都在同一个项目下，如果我们需要引用其他一些已经定义过的功能模块，会非常方便。</li>\\n</ol>\\n<p>我们只需要将复用频率高的代码，单独抽离出来成为一个 shared 之类的项目，那么其他所有的项目都只需要直接引用这个项目下的代码就可以了。而不用将这个项目重新打包，再在其他项目中使用。</p>\\n<ol start=\\"2\\">\\n<li>\\n<p>简化依赖管理\\n由于我们是在同一个项目下，因此对于第三方依赖的管理也会简化很多，像是之前多个项目可能有一些相同的第三方依赖包，每个项目都需要下载一遍，而我们使用 Monorepo 的框架重构项目之后，这些依赖包就可以避免重复下载，同时也能通过配置在不同的项目之间复用。</p>\\n</li>\\n<li>\\n<p>原子提交能让重构全局特性更容易\\n当我们的一个库会影响到很多个项目时，修改了这个库之后，以往我们需要一个一个去更新对应受到影响的项目，进行相应的兼容适配工作，而修改一个问题又可能导致另外一个兼容问题。</p>\\n</li>\\n</ol>","autoDesc":true}');export{e as data};
