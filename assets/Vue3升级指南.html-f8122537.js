import{_ as r,E as o,Z as a,$ as d,a1 as s,a2 as n,a3 as i,a0 as t}from"./framework-f650ad76.js";const p={},u={href:"https://v3.cn.vuejs.org/guide/introduction.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://router.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://pinia.web3doc.top/",target:"_blank",rel:"noopener noreferrer"},f={href:"http://www.axios-js.com/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://element-plus.gitee.io/zh-CN/guide/design.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.vueusejs.com/",target:"_blank",rel:"noopener noreferrer"},k={href:"https://vitejs.cn/",target:"_blank",rel:"noopener noreferrer"},g={href:"https://v3-migration.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.jianshu.com/p/dd19cf798349",target:"_blank",rel:"noopener noreferrer"},V={href:"https://www.freesion.com/article/36781417053/",target:"_blank",rel:"noopener noreferrer"},c={href:"https://blog.csdn.net/qq_42460461/article/details/117898769",target:"_blank",rel:"noopener noreferrer"},w={href:"https://blog.csdn.net/weixin_44869002/article/details/113173819",target:"_blank",rel:"noopener noreferrer"},P={href:"https://blog.csdn.net/weixin_45895753/article/details/126060337",target:"_blank",rel:"noopener noreferrer"},j={href:"https://blog.csdn.net/weixin_44869002/article/details/113174206",target:"_blank",rel:"noopener noreferrer"},y={href:"https://blog.csdn.net/weixin_44869002/article/details/113174738",target:"_blank",rel:"noopener noreferrer"},A={href:"https://v3-migration.vuejs.org/zh/breaking-changes/slots-unification.html",target:"_blank",rel:"noopener noreferrer"};function I(E,e){const l=o("ExternalLinkIcon");return a(),d("div",null,[e[34]||(e[34]=s('<h2 id="vue3-优点" tabindex="-1"><a class="header-anchor" href="#vue3-优点" aria-hidden="true">#</a> vue3 优点</h2><ol><li><p>增加了代码的可维护性 Vue2 使用的是 options 的API ，代码逻辑比较分散，可读性差，可维护性差。Vue3 使用的是 compositionAPI 逻辑分明，可维护性高，更友好的支持TS。在 template 模板中支持多个根节点，支持jsx语法。</p></li><li><p>提升了页面渲染性能 Vue3 在更新DOM算法上，做了优化。在 Vue2 中,每次更新diff，都是全量对比，Vue3则只对比带有标记的，这样大大减少了非动态内容的对比消耗。</p></li><li><p>加强了 MVVM 双向数据绑定的效率 Vue2 的双向数据绑定是利用 ES5 的 Object.definePropert() 对对象属性进行劫持，结合 发布订阅模式的方式来实现的。Vue3 中使用了 es6 的 ProxyAPI 对数据代理。 相比于vue2.x，使用proxy的优势如下：</p></li></ol><p>defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） 可以监听数组，不用再去单独的对数组做特异性操作 vue3.x 可以检测到数组内部数据的变化 4. 项目可持续发展 Vue 2官方还会再维护两年，但两年后的问题和需求，官方就不承诺修复和提供解答了，Vue 3 则不会。</p><p>当然，还有其他的，这里只是列出几个主要的。</p><h2 id="升级存在的隐患" tabindex="-1"><a class="header-anchor" href="#升级存在的隐患" aria-hidden="true">#</a> 升级存在的隐患</h2><ol><li>新的响应式系统用了 Proxy，会存在兼容性问题（不支持IE）。</li><li>框架底层进行了大量重构，新增和删除了很多原来的API，代码结构也发生了变化。很多地方需要进行破坏性修改，从而容易导致各种问题的出现。</li><li>项目使用到的第三方插件和 UI框架（Element）也需要替换和更改成 对应Vue3可用版本。</li></ol><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档" aria-hidden="true">#</a> 参考文档</h2>',7)),n("p",null,[n("a",u,[e[0]||(e[0]=i("Vue3官方文档",-1)),t(l)])]),n("p",null,[n("a",m,[e[1]||(e[1]=i("VueRouter",-1)),t(l)])]),n("p",null,[n("a",v,[e[2]||(e[2]=i("Pinia",-1)),t(l)])]),n("p",null,[n("a",f,[e[3]||(e[3]=i("Axios",-1)),t(l)])]),n("p",null,[n("a",b,[e[4]||(e[4]=i("Element Plus",-1)),t(l)])]),n("p",null,[n("a",h,[e[5]||(e[5]=i("VueUse",-1)),t(l)])]),e[35]||(e[35]=s('<h2 id="代码规范" tabindex="-1"><a class="header-anchor" href="#代码规范" aria-hidden="true">#</a> 代码规范</h2><p>使用 Prettier + ESLint + Husky 组合来实现代码规范化。</p><p>这样做带来好处：</p><ol><li>解决团队之间代码不规范导致的可读性差和可维护性差的问题。</li><li>解决团队成员不同编辑器导致的编码规范不统一问题。</li><li>提前发现代码风格问题，给出对应规范提示，及时修复。 减少代码审查过程中反反复复的修改过程，节约时间。</li><li>自动格式化，统一编码风格，从此和脏乱差的代码说再见。</li></ol><p>VSCode 编辑器 需要去插件市场下载插件 Prettier - Code formatter、ESLint。</p><h2 id="构建工具-vite" tabindex="-1"><a class="header-anchor" href="#构建工具-vite" aria-hidden="true">#</a> 构建工具 Vite</h2>',6)),n("p",null,[e[7]||(e[7]=i("Vite@3.2.3 ",-1)),n("a",k,[e[6]||(e[6]=i("文档链接",-1)),t(l)])]),e[36]||(e[36]=s(`<h2 id="运行要求" tabindex="-1"><a class="header-anchor" href="#运行要求" aria-hidden="true">#</a> 运行要求</h2><p>Vue 版本：3.0以上</p><p>node 版本：Vite 需要 Node.js 版本 &gt;= 12.0.0 我们要求为16.15.0</p><p>pnpm</p><p>nvm或者volta</p><p>浏览器：非IE浏览器</p><h2 id="项目目录结构" tabindex="-1"><a class="header-anchor" href="#项目目录结构" aria-hidden="true">#</a> 项目目录结构</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>├── README.md
├── html
│   └── ie.html           <span class="token comment"># 兼容IE的html</span>
├── index.html            <span class="token comment"># 入口html</span>
├── package.json          <span class="token comment"># 项目依赖</span>
├── pnpm-lock.yaml        <span class="token comment"># pnpm依赖</span>
├── public                <span class="token comment"># 静态资源</span>
│   └── favicon.ico
├── src
│   ├── App.vue           <span class="token comment"># 入口组件</span>
│   ├── api               <span class="token comment"># 接口</span>
│   ├── assets            <span class="token comment"># 静态资源</span>
│   ├── components        <span class="token comment"># 全局公共组件</span>
│   ├── directive         <span class="token comment"># 自定义指令</span>
│   ├── layout            <span class="token comment"># 布局</span>
│   ├── main.js           <span class="token comment"># 项目入口文件</span>
│   ├── permission.js     <span class="token comment"># 路由权限</span>
│   ├── plugins           <span class="token comment"># 公共方法</span>
│   ├── router            <span class="token comment"># 路由</span>
│   ├── settings.js       <span class="token comment"># 项目配置文件（标题、主题等等）</span>
│   ├── store             <span class="token comment"># 全局状态管理</span>
│   ├── utils             <span class="token comment"># 工具类</span>
│   └── views             <span class="token comment"># 页面</span>
├── vite                  <span class="token comment"># vite插件</span>
│   └── plugins
└── vite.config.js        <span class="token comment"># vite配置文件</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="语法和api的改变" tabindex="-1"><a class="header-anchor" href="#语法和api的改变" aria-hidden="true">#</a> 语法和Api的改变</h2>`,9)),n("p",null,[e[9]||(e[9]=i("官方文档： ",-1)),n("a",g,[e[8]||(e[8]=i("Vue 3 迁移指南",-1)),t(l)])]),e[37]||(e[37]=n("h3",{id:"全局-api",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#全局-api","aria-hidden":"true"},"#"),i(" 全局 API")],-1)),n("ol",null,[n("li",null,[e[11]||(e[11]=i("全局 Vue API 已更改为使用应用程序实例 ",-1)),n("a",x,[e[10]||(e[10]=i("参考",-1)),t(l)])]),n("li",null,[e[13]||(e[13]=i("全局和内部 API 已经被重构为支持 tree-shake ",-1)),n("a",V,[e[12]||(e[12]=i("参考",-1)),t(l)])])]),e[38]||(e[38]=n("h3",{id:"模板指令",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#模板指令","aria-hidden":"true"},"#"),i(" 模板指令")],-1)),n("ol",null,[n("li",null,[e[15]||(e[15]=i("组件上 v-model 用法已更改，以替换 v-bind.sync ",-1)),n("a",c,[e[14]||(e[14]=i("参考",-1)),t(l)])]),e[18]||(e[18]=n("li",null,[n("code",null,"<template v-for>"),i(" 和非 v-for 节点上的 key用法已更改")],-1)),e[19]||(e[19]=n("li",null,"在同一元素上使用的 v-if 和 v-for 优先级已更改",-1)),e[20]||(e[20]=n("li",null,"v-bind=“object” 现在排序敏感",-1)),e[21]||(e[21]=n("li",null,"v-on:event.native 修饰符已移除",-1)),n("li",null,[e[17]||(e[17]=i("v-for 中的 ref 不再注册 ref 数组 ",-1)),n("a",w,[e[16]||(e[16]=i("参考",-1)),t(l)])])]),e[39]||(e[39]=n("h3",{id:"组件",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#组件","aria-hidden":"true"},"#"),i(" 组件")],-1)),n("ol",null,[n("li",null,[e[23]||(e[23]=i("只能使用普通函数创建函数式组件 ",-1)),n("a",P,[e[22]||(e[22]=i("参考",-1)),t(l)])]),e[28]||(e[28]=n("li",null,[i("functional attribute 在单文件组件 (SFC) 的 "),n("code",null,"<template>"),i("和 functional 组件选项中被废弃")],-1)),n("li",null,[e[25]||(e[25]=i("异步组件现在需要使用 defineAsyncComponent 方法来创建 ",-1)),n("a",j,[e[24]||(e[24]=i("参考",-1)),t(l)])]),n("li",null,[e[27]||(e[27]=i("组件事件现在需要在 emits 选项中声明 ",-1)),n("a",y,[e[26]||(e[26]=i("参考",-1)),t(l)])])]),e[40]||(e[40]=n("h3",{id:"渲染函数",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#渲染函数","aria-hidden":"true"},"#"),i(" 渲染函数")],-1)),n("ol",null,[e[31]||(e[31]=n("li",null,"渲染函数 API 更改",-1)),n("li",null,[e[30]||(e[30]=i("$scopedSlots property 已移除，所有插槽都通过 $slots 作为函数暴露",-1)),n("a",A,[e[29]||(e[29]=i("参考",-1)),t(l)])]),e[32]||(e[32]=n("li",null,"$listeners 被移除或整合到 $attrs",-1)),e[33]||(e[33]=n("li",null,"$attrs 现在包含 class 和 style attribute",-1))]),e[41]||(e[41]=s('<h3 id="自定义元素" tabindex="-1"><a class="header-anchor" href="#自定义元素" aria-hidden="true">#</a> 自定义元素</h3><ol><li>自定义元素检测现在在模板编译时执行</li><li>特殊的 is attribute 的使用被严格限制在被保留的 <code>&lt;component&gt;</code> 标签中</li></ol><h3 id="其他小改变" tabindex="-1"><a class="header-anchor" href="#其他小改变" aria-hidden="true">#</a> 其他小改变</h3><ol><li>destroyed 生命周期选项被重命名为 unmounted</li><li>beforeDestroy 生命周期选项被重命名为 beforeUnmount</li><li>default prop 工厂函数不再可以访问 this 上下文</li><li>自定义指令的 API 已更改为与组件生命周期一致，且 binding.expression 已移除</li><li>data 选项应始终被声明为一个函数</li><li>来自 mixin 的 data 选项现在为浅合并</li><li>Attribute 强制策略已更改</li><li>一些过渡的 class 被重命名</li><li><code>&lt;TransitionGroup&gt;</code> 不再默认渲染包裹元素</li><li>当侦听一个数组时，只有当数组被替换时，回调才会触发，如果需要在变更时触发，则必须指定 deep 选项</li><li>没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 的 <code>&lt;template&gt;</code> 现在被视为普通元素，并将渲染为原生的 <code>&lt;template&gt;</code> 元素，而不是渲染其内部内容。</li><li>已挂载的应用不会取代它所挂载的元素</li><li>生命周期的 hook: 事件前缀改为 vnode-</li></ol><h3 id="被移除的-api" tabindex="-1"><a class="header-anchor" href="#被移除的-api" aria-hidden="true">#</a> 被移除的 API</h3><ol><li>keyCode 作为 v-on 修饰符的支持</li><li>on、off 和 $once 实例方法</li><li>过滤器 (filter)</li><li>内联模板 attribute</li><li>$children 实例 property</li><li>propsData 选项</li><li>$destroy 实例方法。用户不应再手动管理单个 Vue 组件的生命周期。</li><li>全局函数 set 和 delete 以及实例方法 $set 和 $delete。基于代理的变化检测已经不再需要它们了。</li></ol>',6))])}const S=r(p,[["render",I],["__file","Vue3升级指南.html.vue"]]);export{S as default};
